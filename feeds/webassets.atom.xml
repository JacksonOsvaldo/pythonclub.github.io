<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PythonClub - Webassets</title><link href="http://pythonclub.com.br/" rel="alternate"></link><link href="http://pythonclub.com.br/feeds/webassets.atom.xml" rel="self"></link><id>http://pythonclub.com.br/</id><updated>2016-06-14T17:25:00-03:00</updated><entry><title>Python webassets &amp; Elm</title><link href="http://pythonclub.com.br/python-webassets-elm.html" rel="alternate"></link><published>2016-06-14T17:25:00-03:00</published><updated>2016-06-14T17:25:00-03:00</updated><author><name>Eduardo Cuducos</name></author><id>tag:pythonclub.com.br,2016-06-14:/python-webassets-elm.html</id><summary type="html">&lt;p&gt;Se você é geek e me conhece, ou se me segue nas redes sociais, já ouviu eu falar de &lt;a href="http://elm-lang.org/"&gt;Elm&lt;/a&gt;. É uma solução para &lt;em&gt;front-end&lt;/em&gt; com componentes reativos — mas Elm não é JavaScript. É uma outra linguagem, outro ambiente, outro compilador etc.&lt;/p&gt;
&lt;p&gt;É uma linguagem que muito me impressionou. Sou …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Se você é geek e me conhece, ou se me segue nas redes sociais, já ouviu eu falar de &lt;a href="http://elm-lang.org/"&gt;Elm&lt;/a&gt;. É uma solução para &lt;em&gt;front-end&lt;/em&gt; com componentes reativos — mas Elm não é JavaScript. É uma outra linguagem, outro ambiente, outro compilador etc.&lt;/p&gt;
&lt;p&gt;É uma linguagem que muito me impressionou. Sou novato, engatinhando, tentando levantar e tomando belos tombos. Mas hoje resolvi um desses tombos: como integrar o Elm que uso para &lt;em&gt;front-end&lt;/em&gt; com &lt;em&gt;back-ends&lt;/em&gt; em Python.&lt;/p&gt;
&lt;p&gt;A resposta foi o &lt;a href="https://github.com/cuducos/webassets-elm"&gt;webassets-elm&lt;/a&gt; — pacote que escrevi hoje e já está &lt;a href="https://pypi.python.org/pypi/webassets-elm"&gt;disponível no PyPI&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Nesse texto vou fazer uma pequena introdução sobre interfaces reativas, sobre Elm em si, e depois explico um pouco do problema que o &lt;a href="https://github.com/cuducos/webassets-elm"&gt;webassets-elm&lt;/a&gt; resolve — spoiler: é gambiarra.&lt;/p&gt;
&lt;h2&gt;O que é um &lt;em&gt;front-end&lt;/em&gt; com componente reativo?&lt;/h2&gt;
&lt;p&gt;Componentes reativos são elementos na interface do usuário que seguem a &lt;a href="https://en.wikipedia.org/wiki/Reactive_programming"&gt;programação reativa&lt;/a&gt;: “um paradigma de programação orientado ao fluxo de dados e a propagação de mudanças” — como a Wikipédia define.&lt;/p&gt;
&lt;p&gt;Mas o que isso quer dizer? Comecemos com um exemplo básico &lt;strong&gt;não&lt;/strong&gt; reativo:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# 42&lt;/span&gt;

&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 42&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Se esse bloco fosse reativo, ao mudar o valor de &lt;code&gt;a&lt;/code&gt;, a alteração deveria também mudar o valor de &lt;code&gt;c&lt;/code&gt; — ou seja, o segundo &lt;code&gt;print(c)&lt;/code&gt; deveria resultar em &lt;code&gt;13&lt;/code&gt;, não em &lt;code&gt;42&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Isso é muito útil quando gerenciamos interfaces complexas no &lt;em&gt;front-end&lt;/em&gt;: ao invés de gerenciarmos vários &lt;code&gt;div&lt;/code&gt;, &lt;code&gt;span&lt;/code&gt; com suas classes e conteúdos, definimos uma estrutura de dados e as &lt;em&gt;regras&lt;/em&gt; para renderização desses dados em HTML. Alterando os dados, o HTML é atualizado automaticamente.&lt;/p&gt;
&lt;p&gt;Isso seria uma carroça de lerdeza se tivéssemos que atualizar o &lt;a href="https://pt.wikipedia.org/wiki/Modelo_de_Objeto_de_Documentos"&gt;DOM&lt;/a&gt; cada vez que nossos dados fossem alterados — afinal &lt;a href="https://www.youtube.com/watch?v=hQVTIJBZook"&gt;não é o JavaScript que é lento, o DOM é que é&lt;/a&gt;. Por isso mesmo todos as alternativas para &lt;em&gt;front-end&lt;/em&gt; reativo — &lt;a href="http://elm-lang.org/"&gt;Elm&lt;/a&gt;, &lt;a href="https://facebook.github.io/react/"&gt;React&lt;/a&gt;, &lt;a href="https://vuejs.org/"&gt;Vue&lt;/a&gt; e muitas outras — trabalham com um DOM virtual: todas as alterações são feitas primeiro nesse (eficiente) DOM virtual, que é comparado com o DOM real e então apenas as alterações mínimas são feitas no (lento) DOM real para que a interface seja atualizada. Simples assim.&lt;/p&gt;
&lt;h2&gt;Por quê Elm?&lt;/h2&gt;
&lt;p&gt;Mas por quê Elm? Se praticamente a única linguagem que roda em navegador é JavaScript, que sentido faz aprender Elm? Elm é mais fácil que JavaScript? Essas são perguntas com as quais me habituei. Então vou falar aqui em linhas gerais o que normalmente respondo.&lt;/p&gt;
&lt;p&gt;Não posso negar que JavaScript é mais fácil de aprender — no sentido de que a curva de aprendizado é bem menor. Só que daí até escrever JavaScript de qualidade tem um abismo de distância (alô, &lt;em&gt;&lt;a href="https://medium.com/@joaomilho/festina-lente-e29070811b84#.80xxnrf4f"&gt;technical debt&lt;/a&gt;&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;O que eu gostei no Elm é que, apesar de a curva de aprendizado ser muito maior que a do JavaScript, a linguagem já te força a escrever código com certa qualidade. Por exemplo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Interface reativa de acordo com “melhores práticas”&lt;/strong&gt;: pensar na arquitetura do código é totalmente opcional no JavaScript, mas escrever algo com qualidade vai requerer que você aprenda JavaScript (sem &lt;a href="http://jquery.com"&gt;jQuery&lt;/a&gt;), como usar &lt;a href="https://www.youtube.com/playlist?list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84"&gt;JavaScript de forma funcional&lt;/a&gt;, &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"&gt;Promise&lt;/a&gt;, &lt;a href="https://facebook.github.io/react/"&gt;React&lt;/a&gt;, &lt;a href="http://redux.js.org"&gt;Redux&lt;/a&gt; ou ainda &lt;a href="https://vuejs.org/"&gt;Vue&lt;/a&gt;, para dar alguns exemplos. Então, se juntar a curva de aprendizado de todas coisas, vai ser uma curva de aprendizado parecida com a do próprio Elm (que já é funcional pois é um &lt;a href="https://www.haskell.org"&gt;Heskell&lt;/a&gt; simplificado, já tem &lt;a href="http://guide.elm-lang.org/architecture/index.html"&gt;sua própria arquitetura&lt;/a&gt; etc.)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Erros&lt;/strong&gt;: Com JavaScript (incluindo jQuery, ReactJs, Vue etc.) pode acontecer de passar erros para a produção ou homologação — um caso raro no qual uma função espere &lt;code&gt;x&lt;/code&gt;, mas receba &lt;code&gt;y&lt;/code&gt;, um loop infinito, uma função ou variável não definida, um objeto não encontrado. Com Elm, não: o compilador já elimina trocentos mil possibilidades de erro na compilação (como dizem na home do Elm, no &lt;em&gt;runtime exceptions&lt;/em&gt;). Isso porquê o Elm já trabalha com tipagem e com objetos imutáveis, e consegue verificar possibilidades que o cérebro humano demoraria para imaginar. Se tem alguma possibilidade de teu código receber &lt;code&gt;String&lt;/code&gt; quando espera &lt;code&gt;Integer&lt;/code&gt;, ou de cair em um &lt;code&gt;import&lt;/code&gt; cíclico, ele não compila se você não corrigir. Ele é chato, mas não deixa passar erro.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mensagens de erro&lt;/strong&gt;: Se o Elm é chato por não compilar se houver possibilidade de erro, suas mensagens não são nada chatas. Na minha opinião uma das coisas mais chatas de desenvolver com JavaScript é que a console é muito ruim: as mensagens são vagas, é o terror do &lt;code&gt;undefined is not a function&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt; etc. Já as mensagens de erro do compilador do Elm são muito educativas, te mostram o que está errado, onde está errado e, muitas vezes, como resolver.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Compiler errors for humans" src="http://elm-lang.org/assets/blog/error-messages/0.15.1/naming.png"&gt;&lt;/p&gt;
&lt;p&gt;Por fim, o JavaScript é muito verboso. Muito. Elm é mais conciso. Sem contar que ninguém vai se perder tentando descobrir se tem que fechar o parênteses antes das chaves, ou depois do ponto-e-vírgula.&lt;/p&gt;
&lt;p&gt;Enfim, se se interessam por Elm, além dos links que coloquei no texto, sugiro mais esses (todos em inglês):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://egghead.io/lessons/elm-elm-in-5-minutes"&gt;Elm em 7 minutos&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ohanhi.github.io/master-elm-1-why-elm.html"&gt;Por quê Elm — parte 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/3_M2G9U51GA"&gt;Introdução ao Elm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Webassets &amp;amp; webassets-elm&lt;/h2&gt;
&lt;p&gt;Para quem não conhece, o &lt;a href="http://webassets.readthedocs.io/"&gt;webassets&lt;/a&gt; é pacote muito utilizado no mundo Python para compilar, dar um &lt;em&gt;minify&lt;/em&gt; e comprimir CSS, JS etc. Por exemplo ele tem filtros que transformam o todos os &lt;a href="http://sass-lang.com"&gt;SASS&lt;/a&gt; em CSS e, depois, junta tudo em um único &lt;code&gt;.css&lt;/code&gt; bem compacto.&lt;/p&gt;
&lt;p&gt;A integração com &lt;a href="http://flask.pocoo.org"&gt;Flask&lt;/a&gt; ou &lt;a href="http://djangoproject.com"&gt;Django&lt;/a&gt; é super fácil e útil com o &lt;a href="http://flask-assets.readthedocs.io/"&gt;flask-assets&lt;/a&gt; ou &lt;a href="http://django-assets.readthedocs.org/"&gt;django-assets&lt;/a&gt;. Com isso sua própria aplicação gera, no servidor, seus &lt;em&gt;assets&lt;/em&gt;. Em ambiente de desenvolvimento e produção a geração dos &lt;em&gt;assets&lt;/em&gt; passa a ocorrer automaticamente (sem necessidade de &lt;em&gt;watchers&lt;/em&gt; ou de rodar manualmente &lt;code&gt;sass&lt;/code&gt;, &lt;code&gt;coffee&lt;/code&gt;, &lt;code&gt;browserify&lt;/code&gt;, &lt;code&gt;webpack&lt;/code&gt;, &lt;code&gt;grunt&lt;/code&gt;, &lt;code&gt;gulp&lt;/code&gt; etc.).&lt;/p&gt;
&lt;p&gt;O &lt;a href="https://github.com/cuducos/webassets-elm"&gt;webassets-elm&lt;/a&gt; nada mais é, então, do que um filtro para o &lt;em&gt;webassets&lt;/em&gt; saber o que fazer com arquivos &lt;code&gt;.elm&lt;/code&gt; — ou seja para transformar meus arquivos em Elm em &lt;code&gt;.js&lt;/code&gt; para o navegador saber o que fazer com eles (isso é o que chamamos de &lt;em&gt;compilar&lt;/em&gt; no Elm). Parece simples, e a arquitetura do &lt;em&gt;webassets&lt;/em&gt; ajuda muito: eles mesmos oferecem um objeto &lt;a href="https://github.com/miracle2k/webassets/blob/master/src/webassets/filter/__init__.py#L400-L456"&gt;&lt;code&gt;ExternalTool&lt;/code&gt;&lt;/a&gt; para facilitar a criação de filtros personalizados.&lt;/p&gt;
&lt;p&gt;O que quero é que na hora que eu rodar minha aplicação em Flask ou em Django, se eu tiver alterado qualquer arquivo &lt;code&gt;.elm&lt;/code&gt; (ou &lt;code&gt;.sass&lt;/code&gt;), por exemplo, automaticamente a aplicação já gere um &lt;code&gt;.js&lt;/code&gt; (ou &lt;code&gt;.css&lt;/code&gt;) atualizado.&lt;/p&gt;
&lt;p&gt;O problema é que toda a arquitetura do &lt;em&gt;webassets&lt;/em&gt; é pensada tendo o &lt;a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29"&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; como padrão. E o &lt;code&gt;elm-make&lt;/code&gt; (comando que compila os arquivos Elm) &lt;a href="https://github.com/elm-lang/elm-make/issues/39"&gt;só grava em arquivo, não joga o resultado para o &lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;Faz sentido o &lt;em&gt;webassets&lt;/em&gt; ser assim: muitas vezes o que interessa é só o resultado das compilações, já que esses resultados podem ser processados novamente (um &lt;em&gt;minify&lt;/em&gt;, por exemplo) antes de se juntar a outros resultados para, finalmente, salvar um asset &lt;code&gt;.css&lt;/code&gt; ou &lt;code&gt;.js&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Então, a única complicação no &lt;em&gt;webassets-elm&lt;/em&gt; é essa — aí mora a famosa &lt;em&gt;gambiarra&lt;/em&gt;, o famoso &lt;em&gt;jeitinho brasileiro&lt;/em&gt; enquanto o &lt;code&gt;elm-make&lt;/code&gt; não oferece uma forma de compilar para o &lt;code&gt;stdout&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Estrutura de um filtro do &lt;em&gt;webassets&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;Normalmente um &lt;a href="https://webassets.readthedocs.io/en/latest/custom_filters.html"&gt;filtro para o &lt;em&gt;webassets&lt;/em&gt; é simples&lt;/a&gt;, veja esse exemplo (simplificado) de &lt;a href="https://github.com/renstrom/webassets-browserify/blob/master/webassets_browserify/__init__.py"&gt;um filtro para utilizar o Browserify&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Browserify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ExternalTool&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;browserify&amp;#39;&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;infile&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;outfile&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;binary&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;browserify&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;source_path&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;outfile&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;infile&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Basicamente dentro de &lt;code&gt;input(…)&lt;/code&gt;, que recebe o arquivo de entrada (&lt;code&gt;infile&lt;/code&gt;) e o arquivo de saída (&lt;code&gt;outfile&lt;/code&gt;), definimos qual o binário a ser chamado (&lt;code&gt;browserify&lt;/code&gt;, por padrão, no exemplo) e adicionamos os argumentos que queremos passar para o binário (&lt;code&gt;kwargs['source_path']&lt;/code&gt;). Tudo muito parecido com o &lt;a href="https://docs.python.org/3.5/library/subprocess.html"&gt;&lt;code&gt;subprocess&lt;/code&gt; nativo do Python&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Em outras palavras, se o &lt;code&gt;source_path&lt;/code&gt; for &lt;code&gt;/home/johndoe/42.sass&lt;/code&gt;, é como se digitássemos &lt;code&gt;browserify /home/johndoe/42.sass&lt;/code&gt; no terminal e o &lt;em&gt;webassets&lt;/em&gt; juntaria o resultado desse comando no arquivo final (&lt;code&gt;outfile&lt;/code&gt;).&lt;/p&gt;
&lt;h3&gt;Estrutura do &lt;em&gt;webassets-elm&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;Mas o &lt;code&gt;elm-make&lt;/code&gt; não funciona assim. Ele gera uma arquivo. Se chamarmos &lt;code&gt;elm-make hello.elm&lt;/code&gt; ele gera um &lt;code&gt;index.html&lt;/code&gt; (com o JavaScript compilado dentro). Podemos gerar apenas um JavaScript usando o argumento &lt;code&gt;--output&lt;/code&gt;. Por exemplo, podemos usar &lt;code&gt;elm-make hello.elm --output hello.js&lt;/code&gt; e teríamos apenas o JavaScript compilado no arquivo &lt;code&gt;hello.js&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Por esse motivo o &lt;em&gt;webassets-elm&lt;/em&gt; precisou de &lt;a href="https://github.com/cuducos/webassets-elm/blob/master/webassets_elm/__init__.py#L25-L43"&gt;uma gambiarra&lt;/a&gt;. Primeiro ele chama o &lt;code&gt;elm-make&lt;/code&gt; gravando um arquivo temporário:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mkstemp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;suffix&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;.js&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;elm_make&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;binary&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;elm-make&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;write_args&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;elm_make&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;source_path&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;--output&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;--yes&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;TemporaryFile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;fake_write_obj&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;write_args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fake_write_obj&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Depois usa o &lt;code&gt;cat&lt;/code&gt; (ou &lt;code&gt;type&lt;/code&gt;, no Windows) para jogar o conteúdo desse arquivo temporário para o &lt;code&gt;stdout&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;cat_or_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;type&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;platform&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;win32&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;cat&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;read_args&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;cat_or_type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;read_args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Não sei se é a melhor solução, mas foi o que resolveu por enquanto. Qualquer palpite, crítica, &lt;em&gt;pull request&lt;/em&gt;, &lt;a href="https://twitter.com/cuducos/status/742698891343204353"&gt;RT&lt;/a&gt;, estrelinha no GitHub, &lt;em&gt;issue&lt;/em&gt;, contribuição é bem-vinda ; )&lt;/p&gt;</content><category term="elm"></category><category term="webassets"></category><category term="flask"></category><category term="django"></category></entry></feed>